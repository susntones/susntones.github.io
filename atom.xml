<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>进击的白石</title>
  
  <subtitle>记录下自己的成长，毕竟做程序员这么久了。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-28T14:09:45.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>刘白石</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019-h2书单</title>
    <link href="http://yoursite.com/2019/07/28/2019-h2%E4%B9%A6%E5%8D%95/"/>
    <id>http://yoursite.com/2019/07/28/2019-h2书单/</id>
    <published>2019-07-27T16:00:00.000Z</published>
    <updated>2019-07-28T14:09:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="研发类"><a href="#研发类" class="headerlink" title="研发类"></a>研发类</h2><ul><li style="list-style: none"><input type="checkbox" checked> Elasticsearch服务器开发</li><li style="list-style: none"><input type="checkbox"> Hadoop权威指南</li><li style="list-style: none"><input type="checkbox"> 深入理解Nginx</li></ul><h2 id="自我提升"><a href="#自我提升" class="headerlink" title="自我提升"></a>自我提升</h2><ul><li style="list-style: none"><input type="checkbox" checked> 人性的弱点</li><li style="list-style: none"><input type="checkbox"> 社会心理学</li><li style="list-style: none"><input type="checkbox"> 富爸爸穷爸爸</li><li style="list-style: none"><input type="checkbox"> 自卑与超越</li></ul><h2 id="小说"><a href="#小说" class="headerlink" title="小说"></a>小说</h2><ul><li style="list-style: none"><input type="checkbox" checked> 许三观买血记</li><li style="list-style: none"><input type="checkbox"> 挪威的森林</li><li style="list-style: none"><input type="checkbox"> 月亮和六便士</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;研发类&quot;&gt;&lt;a href=&quot;#研发类&quot; class=&quot;headerlink&quot; title=&quot;研发类&quot;&gt;&lt;/a&gt;研发类&lt;/h2&gt;&lt;ul&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot; checked&gt; Ela
      
    
    </summary>
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>dynamic-programming</title>
    <link href="http://yoursite.com/2019/07/22/dynamic-programming/"/>
    <id>http://yoursite.com/2019/07/22/dynamic-programming/</id>
    <published>2019-07-22T03:24:24.000Z</published>
    <updated>2019-07-28T13:36:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><p>处理DP问题的两种方式</p><ul><li>记忆化搜索</li><li>循环，包括自底向上和自顶向下两种方式。</li></ul><p>DP常见的问题类型</p><ul><li>matrix dp</li><li>sequence</li><li>two sequence dp</li><li>backpack</li></ul><p>动态规划的4点要素</p><ul><li><p>状态 State</p><p>存储小规模问题的结果。</p></li><li><p>方程 Function</p><p>状态之间的联系，怎样通过小的状态，来算大的状态。</p></li><li><p>初始化 Intialization</p><p>最极限的小状态</p></li><li><p>答案 Answer</p><p>最终状态</p></li></ul><h2 id="Matrix-dp"><a href="#Matrix-dp" class="headerlink" title="Matrix dp"></a>Matrix dp</h2><h3 id="Triangle"><a href="#Triangle" class="headerlink" title="Triangle"></a>Triangle</h3><p>这道题有多种解决方法：</p><ul><li>递归<ul><li>遍历</li><li>分治</li></ul></li><li>DP<ul><li>记忆化搜索</li><li>循环（自底向上 + 自定向下）</li></ul></li></ul><p><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">leedcode地址</a></p><p>分治的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var minimumTotal = function(triangle) &#123;</span><br><span class="line">  return getMinPath(0, 0, triangle);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function getMinPath(x, y, triangle) &#123;</span><br><span class="line">  if (x === triangle.length - 1) &#123;</span><br><span class="line">    return triangle[x][y];</span><br><span class="line">  &#125;</span><br><span class="line">  var left = getMinPath(x + 1, y, triangle);</span><br><span class="line">  var right = getMinPath(x + 1, y + 1, triangle);</span><br><span class="line">  return Math.min(left, right) + triangle[x][y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>DP 循环（自底向上）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var minimumTotal = function(triangle) &#123;</span><br><span class="line">    var length = triangle.length;</span><br><span class="line">    var array = [];</span><br><span class="line">    for (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        for(var j = 0; j &lt; length - i; j++) &#123;</span><br><span class="line">            if (i === 0) &#123;</span><br><span class="line">                array[j] = triangle[length - i - 1][j];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                array[j] = Math.min(array[j], array[j + 1]) + triangle[length - i - 1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array[0];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="Unique-paths"><a href="#Unique-paths" class="headerlink" title="Unique paths"></a>Unique paths</h3><p><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var uniquePaths = function(m, n) &#123;</span><br><span class="line">    var paths = [];</span><br><span class="line">    for (var j = 0; j &lt; n; j++) &#123;</span><br><span class="line">        paths[j] = [];</span><br><span class="line">        paths[j][0] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (var i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        paths[0][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (var height = 1; height &lt; n; height++) &#123;</span><br><span class="line">        for (var weight = 1; weight &lt; m; weight ++) &#123;</span><br><span class="line">            paths[height][weight] = paths[height - 1][weight] + paths[height][weight - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return paths[n - 1][m - 1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Unique-paths-II"><a href="#Unique-paths-II" class="headerlink" title="Unique paths II"></a>Unique paths II</h3><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var uniquePathsWithObstacles = function(obstacleGrid) &#123;</span><br><span class="line">    var m = obstacleGrid[0].length;</span><br><span class="line">    var n = obstacleGrid.length;</span><br><span class="line">    var paths = [];</span><br><span class="line">    for (var j = 0; j &lt; n; j++) &#123;</span><br><span class="line">        paths[j] = [];</span><br><span class="line">        if (obstacleGrid[j][0] === 1 || (j &gt; 0 &amp;&amp; paths[j - 1][0] === 0)) &#123;</span><br><span class="line">            paths[j][0] = 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            paths[j][0] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (var i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        if (obstacleGrid[0][i] === 1 || (i &gt; 0 &amp;&amp; paths[0][i - 1] === 0)) &#123;</span><br><span class="line">            paths[0][i] = 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            paths[0][i] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (var height = 1; height &lt; n; height++) &#123;</span><br><span class="line">        for (var weight = 1; weight &lt; m; weight ++) &#123;</span><br><span class="line">            if (obstacleGrid[height][weight] === 1) &#123;</span><br><span class="line">                paths[height][weight] = 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                paths[height][weight] = paths[height - 1][weight] + paths[height][weight - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return paths[n - 1][m - 1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Sequence-dp"><a href="#Sequence-dp" class="headerlink" title="Sequence dp"></a>Sequence dp</h2><h3 id="Climbing-stairs"><a href="#Climbing-stairs" class="headerlink" title="Climbing stairs"></a>Climbing stairs</h3><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var climbStairs = function(n) &#123;</span><br><span class="line">    if (n === 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    var nums = [];</span><br><span class="line">    nums[0] = 1;</span><br><span class="line">    nums[1] = 1;</span><br><span class="line">    for (var i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        nums[i] = nums[i - 2] + nums[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    return nums[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Jump-game"><a href="#Jump-game" class="headerlink" title="Jump game"></a>Jump game</h3><p><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var canJump = function(nums) &#123;</span><br><span class="line">    var length = nums.length;</span><br><span class="line">    var canJumpArray = [];</span><br><span class="line">    canJumpArray[0] = true;</span><br><span class="line">    for (var i = 1; i &lt; length; i++) &#123;</span><br><span class="line">        canJumpArray[i] = false;</span><br><span class="line">        for (var j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">            if (canJumpArray[j] &amp;&amp; nums[j] &gt;= i - j) &#123;</span><br><span class="line">                canJumpArray[i] = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return canJumpArray[length - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jump-game-II"><a href="#Jump-game-II" class="headerlink" title="Jump game II"></a>Jump game II</h3><p><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">leedcode地址</a></p><p>DP的解法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var jump = function(nums) &#123;</span><br><span class="line">    var length = nums.length;</span><br><span class="line">    var jumpNums = [];</span><br><span class="line">    jumpNums[0] = 0;</span><br><span class="line">    for (var i = 1; i &lt; length; i++) &#123;</span><br><span class="line">        jumpNums[i] = Infinity;</span><br><span class="line">        for (var j = i - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">            if (jumpNums[j] !== Infinity &amp;&amp; nums[j] &gt;= i - j) &#123;</span><br><span class="line">                jumpNums[i] = Math.min(jumpNums[j] + 1, jumpNums[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return jumpNums[length - 1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>贪心的方法</p><pre><code>从一个位置跳到它能跳到的最远位置之间的都只需要一步!所以,如果一开始都能跳到,后面再跳到的肯定步数要变多!</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var jump = function(nums) &#123;</span><br><span class="line">    if (nums.length &lt;= 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    var length = nums.length;</span><br><span class="line">    var result = [];</span><br><span class="line">    result[0] = 0;</span><br><span class="line">    for (var i = 0; i &lt; length; i ++) &#123;</span><br><span class="line">        for(var j = nums[i]; j &gt; 0; j--) &#123;</span><br><span class="line">            if (i + j &gt;= length - 1) &#123;</span><br><span class="line">                return result[i] + 1;</span><br><span class="line">            &#125; else if (result[i + j] === undefined) &#123;</span><br><span class="line">                result[i + j] = result[i] + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result[length - 1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Palindrome-partitioning"><a href="#Palindrome-partitioning" class="headerlink" title="Palindrome partitioning"></a>Palindrome partitioning</h3><p><a href="https://leetcode-cn.com/problems/palindrome-partitioning/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var partition = function(s) &#123;</span><br><span class="line">    var buffer = new Buffer(s);</span><br><span class="line">    var length = buffer.length;</span><br><span class="line">    var array = [];</span><br><span class="line">    array[0] = [[]];</span><br><span class="line">    for (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        array[i + 1] = [];</span><br><span class="line">        for (var j = i; j &gt;=0; j--) &#123;</span><br><span class="line">            var isPal = isPalindrome(buffer, j, i);</span><br><span class="line">            var str = buffer.slice(j, i + 1).toString();</span><br><span class="line">            if (isPal) &#123;</span><br><span class="line">                for(var iterm of array[j]) &#123;</span><br><span class="line">                    var clone = iterm.concat();</span><br><span class="line">                    clone.push(str)</span><br><span class="line">                    array[i + 1].push(clone);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array[length];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function isPalindrome(buffer, start, end) &#123;</span><br><span class="line">    var result = true;</span><br><span class="line">    while (start &lt; end) &#123;</span><br><span class="line">        if (buffer[start] !== buffer[end]) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Palindrome-partitioning-II"><a href="#Palindrome-partitioning-II" class="headerlink" title="Palindrome partitioning II"></a>Palindrome partitioning II</h3><p><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var minCut = function(s) &#123;</span><br><span class="line">    var buffer = new Buffer(s);</span><br><span class="line">    var length = buffer.length;</span><br><span class="line">    var array = [];</span><br><span class="line">    array[0] = [0];</span><br><span class="line">    for (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        array[i + 1] = Infinity;</span><br><span class="line">        for (var j = i; j &gt;=0; j--) &#123;</span><br><span class="line">            var isPal = isPalindrome(buffer, j, i);</span><br><span class="line">            if (isPal) &#123;</span><br><span class="line">                array[i + 1] = Math.min(array[i + 1], array[j] + 1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array[length] - 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function isPalindrome(buffer, start, end) &#123;</span><br><span class="line">    var result = true;</span><br><span class="line">    while (start &lt; end) &#123;</span><br><span class="line">        if (buffer[start] !== buffer[end]) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Word-break"><a href="#Word-break" class="headerlink" title="Word break"></a>Word break</h3><p><a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var wordBreak = function(s, wordDict) &#123;</span><br><span class="line">    var minLength = Infinity;</span><br><span class="line">    var maxLength = 0;</span><br><span class="line">    wordDict.forEach((word) =&gt; &#123;</span><br><span class="line">        minLength = Math.min(minLength, word.length);</span><br><span class="line">        maxLength = Math.max(maxLength, word.length);</span><br><span class="line">    &#125;)</span><br><span class="line">    if (minLength &gt; s.length) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    var array = [];</span><br><span class="line">    for (var i = minLength - 1; i &lt; s.length; i++) &#123;</span><br><span class="line">        for (var j = minLength; j &lt;= maxLength; j++) &#123;</span><br><span class="line">            if (wordDict.includes(s.slice(i - j + 1, i + 1)) &amp;&amp; (i - j &lt; 0 || array[i - j])) &#123;</span><br><span class="line">                array[i] = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array[s.length - 1] ? true : false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Longest-increasing-subsequence（LIS）"><a href="#Longest-increasing-subsequence（LIS）" class="headerlink" title="Longest increasing subsequence（LIS）"></a>Longest increasing subsequence（LIS）</h3><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var lengthOfLIS = function(nums) &#123;</span><br><span class="line">    if (nums.length === 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    var dp = [];</span><br><span class="line">    var max = 0;</span><br><span class="line">    for (var i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = 1;</span><br><span class="line">        for (var j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Edit-distance"><a href="#Edit-distance" class="headerlink" title="Edit distance"></a>Edit distance</h3><p><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var minDistance = function(word1, word2) &#123;</span><br><span class="line">    var m = word1.length;</span><br><span class="line">    var n = word2.length;</span><br><span class="line">    var dp = [];</span><br><span class="line">    for (var i = 0; i &lt;= m; i++) &#123;</span><br><span class="line">        dp[i] = [];</span><br><span class="line">        dp[i][0] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[0][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        for(j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">            if(word1.charAt(i - 1) == word2.charAt(j - 1)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><a href="https://github.com/tianyicui/pack" target="_blank" rel="noopener">背包问题九讲</a></p><h3 id="Partition-equal-subset-sum"><a href="#Partition-equal-subset-sum" class="headerlink" title="Partition equal subset sum"></a>Partition equal subset sum</h3><p>&emsp;&emsp;01背包问题</p><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var canPartition = function(nums) &#123;</span><br><span class="line">    var sum = 0;</span><br><span class="line">    for (var i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    if (sum % 2) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    var mid = sum / 2;</span><br><span class="line">    var dp = [];</span><br><span class="line">    for (i = 0; i &lt;= nums.length; i++) &#123;</span><br><span class="line">        dp[i] = [];</span><br><span class="line">        dp[i][0] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 1; i &lt;= mid; i++) &#123;</span><br><span class="line">        dp[0][i] = false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 1; i &lt;= nums.length; i++) &#123;</span><br><span class="line">        for (var j = 1; j &lt;= mid; j++) &#123;</span><br><span class="line">            if (nums[i - 1] &gt; j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[nums.length][mid];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Coin-change"><a href="#Coin-change" class="headerlink" title="Coin change"></a>Coin change</h3><p>&emsp;&emsp;完全背包</p><p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var coinChange = function(coins, amount) &#123;</span><br><span class="line">    var dp = [0];</span><br><span class="line">    for (var i = 1; i &lt;= amount; i++) &#123;</span><br><span class="line">        dp[i] = -1;</span><br><span class="line">        for (var coin of coins) &#123;</span><br><span class="line">            if (coin &gt; i || dp[i - coin] === -1) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (dp[i] === -1) &#123;</span><br><span class="line">                dp[i] = dp[i - coin] + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i - coin] + 1, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[amount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Combination-sum"><a href="#Combination-sum" class="headerlink" title="Combination sum"></a>Combination sum</h3><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/" target="_blank" rel="noopener">leedcode地址</a></p><p>&emsp;&emsp;完全背包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var combinationSum4 = function(nums, target) &#123;</span><br><span class="line">    var dp = [];</span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    for (var i = 1; i &lt;= target; i++) &#123;</span><br><span class="line">        dp[i] = 0;</span><br><span class="line">        for(var num of nums) &#123;</span><br><span class="line">            if (num &gt; i || dp[i - num] === 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i] += dp[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[target];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Ones-and-zeroes"><a href="#Ones-and-zeroes" class="headerlink" title="Ones and zeroes"></a>Ones and zeroes</h3><p><a href="https://leetcode-cn.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var findMaxForm = function(strs, m, n) &#123;</span><br><span class="line">    var dp = [];</span><br><span class="line">    for(var mi = 0; mi &lt;= m; mi++) &#123;</span><br><span class="line">        dp[mi] = [];</span><br><span class="line">        for(var ni = 0; ni &lt;= n; ni++) &#123;</span><br><span class="line">            dp[mi][ni] = [];</span><br><span class="line">            for(var j = 0; j &lt;= strs.length; j++) &#123;</span><br><span class="line">                if (j === 0) &#123;</span><br><span class="line">                    dp[mi][ni][j] = 0;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                var str = strs[j - 1];</span><br><span class="line">                var s0 = 0;</span><br><span class="line">                var s1 = 0;</span><br><span class="line">                for(var index = 0; index &lt; str.length; index++) &#123;</span><br><span class="line">                if (str.charAt(index) === &quot;0&quot;) &#123;</span><br><span class="line">                    s0++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    s1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (s0 &gt; mi || s1 &gt; ni) &#123;</span><br><span class="line">                dp[mi][ni][j] = dp[mi][ni][j - 1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[mi][ni][j] = Math.max(dp[mi][ni][j - 1], dp[mi - s0][ni - s1][j - 1] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return dp[m][n][strs.length];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Dynamic-Programming&quot;&gt;&lt;a href=&quot;#Dynamic-Programming&quot; class=&quot;headerlink&quot; title=&quot;Dynamic Programming&quot;&gt;&lt;/a&gt;Dynamic Programming&lt;/h1&gt;&lt;p&gt;处理
      
    
    </summary>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-problems</title>
    <link href="http://yoursite.com/2019/07/21/leetcode-problems/"/>
    <id>http://yoursite.com/2019/07/21/leetcode-problems/</id>
    <published>2019-07-21T08:41:30.000Z</published>
    <updated>2019-07-28T13:36:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-Problems"><a href="#Leetcode-Problems" class="headerlink" title="Leetcode Problems"></a>Leetcode Problems</h1><p>leetcode 一些题目答案的整理。</p><h3 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a>Permutations</h3><p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var permute = function(nums) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    if(nums.length === 0) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    fun(nums, [], result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var fun = function(nums, current, result) &#123;</span><br><span class="line">    for(var i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        current.push(nums[i]);</span><br><span class="line">        const numsCopy = nums.concat();</span><br><span class="line">        numsCopy.splice(i, 1);</span><br><span class="line">        if (numsCopy.length === 0) &#123;</span><br><span class="line">            result.push(current.concat());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fun(numsCopy, current, result);</span><br><span class="line">        &#125;</span><br><span class="line">        current.pop(nums[i]); // 回溯。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="N-queens"><a href="#N-queens" class="headerlink" title="N queens"></a>N queens</h3><p>&emsp;&emsp;经典的n皇后问题，主要解题思路是广度优先搜索和回溯。</p><p><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">var solveNQueens = function(n) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    var chessboard = [];</span><br><span class="line">    // 初始化棋盘</span><br><span class="line">    for (var x = 0; x &lt; n; x++) &#123;</span><br><span class="line">        chessboard[x] = [];</span><br><span class="line">        for (var y = 0; y &lt; n; y++) &#123;</span><br><span class="line">            chessboard[x] += &quot;.&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(0, [], result, chessboard, n);</span><br><span class="line">    return result</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function backtrack(row, queenCoordinates, results, chessboard, n) &#123; // 回溯的方法。</span><br><span class="line">    for(var i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (!isConflict(queenCoordinates, row, i)) &#123;</span><br><span class="line">            queenCoordinates.push(&#123; x: row, y: i&#125;);</span><br><span class="line">            if (row + 1 === n) &#123;</span><br><span class="line">                const result = chessboard.concat();</span><br><span class="line">                for (var coordinate of queenCoordinates) &#123;</span><br><span class="line">                    result[coordinate.x] = result[coordinate.x].slice(0, coordinate.y) + &quot;Q&quot; + result[coordinate.x].slice(coordinate.y + 1);</span><br><span class="line">                &#125;</span><br><span class="line">                results.push(result);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                backtrack(row + 1, queenCoordinates.concat(), results, chessboard, n);</span><br><span class="line">            &#125;</span><br><span class="line">            queenCoordinates.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isConflict(queenCoordinates, x, y) &#123; // 判断棋子是否冲突了。</span><br><span class="line">    for(var i = 0; i &lt; queenCoordinates.length; i++) &#123;</span><br><span class="line">        const coordinate = queenCoordinates[i];</span><br><span class="line">        if (coordinate.x === x || coordinate.y === y ||</span><br><span class="line">            (coordinate.y - coordinate.x) === (y - x) ||</span><br><span class="line">            (coordinate.y + coordinate.x) === (x + y)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Single-number"><a href="#Single-number" class="headerlink" title="Single number"></a>Single number</h3><p>&emsp;&emsp;使用了异或的特性。</p><p><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var singleNumber = function(nums) &#123;</span><br><span class="line">    var result = 0;</span><br><span class="line">    for(var i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        result = result ^ nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Majority-element"><a href="#Majority-element" class="headerlink" title="Majority element"></a>Majority element</h3><p>&emsp;&emsp;不同元素抵消，剩余的元素一定是 Majority element;</p><p><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var majorityElement = function(nums) &#123;</span><br><span class="line">    var array = [];</span><br><span class="line">    var head;</span><br><span class="line">    for (var i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (nums[i] != head &amp;&amp; array.length !== 0) &#123;</span><br><span class="line">            array.pop();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            array.push(nums[i]);</span><br><span class="line">            head = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array.pop();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Leetcode-Problems&quot;&gt;&lt;a href=&quot;#Leetcode-Problems&quot; class=&quot;headerlink&quot; title=&quot;Leetcode Problems&quot;&gt;&lt;/a&gt;Leetcode Problems&lt;/h1&gt;&lt;p&gt;leetcode 一
      
    
    </summary>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>linked-list</title>
    <link href="http://yoursite.com/2019/06/24/linked-list/"/>
    <id>http://yoursite.com/2019/06/24/linked-list/</id>
    <published>2019-06-24T14:21:31.000Z</published>
    <updated>2019-06-24T14:21:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linked-List"><a href="#Linked-List" class="headerlink" title="Linked List"></a>Linked List</h1><h3 id="Remove-duplicates-from-sorted-list"><a href="#Remove-duplicates-from-sorted-list" class="headerlink" title="Remove duplicates from sorted list"></a>Remove duplicates from sorted list</h3><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var deleteDuplicates = function(head) &#123;</span><br><span class="line">    if (!head) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    var pre = head;</span><br><span class="line">    var current = head.next;</span><br><span class="line">    var currentVal = head.val;</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        if (current.val === currentVal) &#123;</span><br><span class="line">            pre.next = current.next;</span><br><span class="line">            current = pre.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            currentVal = current.val;</span><br><span class="line">            pre = current;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Remove-duplicates-from-sorted-list-II"><a href="#Remove-duplicates-from-sorted-list-II" class="headerlink" title="Remove duplicates from sorted list II"></a>Remove duplicates from sorted list II</h3><p>&emsp;&emsp;考虑使用dummy node</p><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var deleteDuplicates = function(head) &#123;</span><br><span class="line">    if (!head) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    var dummyNode = new ListNode(null);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    var prePre = dummyNode;</span><br><span class="line">    var pre = head;</span><br><span class="line">    var current = head.next;</span><br><span class="line">    var currentVal = head.val;</span><br><span class="line">    var isDupl = false;</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        if (current.val === currentVal) &#123;</span><br><span class="line">            isDupl = true;</span><br><span class="line">            pre.next = current.next;</span><br><span class="line">            current = pre.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            currentVal = current.val;</span><br><span class="line">            if (isDupl) &#123;</span><br><span class="line">                prePre.next = current;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                prePre = pre;</span><br><span class="line">            &#125;</span><br><span class="line">            isDupl = false;</span><br><span class="line">            pre = current;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (isDupl) &#123;</span><br><span class="line">        prePre.next = current;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyNode.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Reverse-linked-list"><a href="#Reverse-linked-list" class="headerlink" title="Reverse linked list"></a>Reverse linked list</h3><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var reverseList = function(head) &#123;</span><br><span class="line">    var pre = null;</span><br><span class="line">    while (head) &#123;</span><br><span class="line">        var next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre; // 此处要注意return pre；</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Reverse-linked-list-II"><a href="#Reverse-linked-list-II" class="headerlink" title="Reverse linked list II"></a>Reverse linked list II</h3><p>&emsp;&emsp;需要使用dummy node</p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var reverseBetween = function(head, m, n) &#123;</span><br><span class="line">    var dummyNode = new ListNode(null);</span><br><span class="line">    var preNode = dummyNode;</span><br><span class="line">    var nextNode = null;</span><br><span class="line">    var currentNode = head;</span><br><span class="line">    for (var i = 1; i &lt; m; i++) &#123;</span><br><span class="line">        preNode.next = currentNode;</span><br><span class="line">        preNode = currentNode;</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    nextNode = currentNode;</span><br><span class="line">    var reversePre = null;</span><br><span class="line">    for (var j = m; j &lt;= n; j++) &#123;</span><br><span class="line">        var next = currentNode.next;</span><br><span class="line">        currentNode.next = reversePre;</span><br><span class="line">        reversePre = currentNode;</span><br><span class="line">        currentNode = next;</span><br><span class="line">    &#125;</span><br><span class="line">    preNode.next = reversePre;</span><br><span class="line">    nextNode.next = currentNode;</span><br><span class="line">    return dummyNode.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Partition-list"><a href="#Partition-list" class="headerlink" title="Partition list"></a>Partition list</h3><p><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var partition = function(head, x) &#123;</span><br><span class="line">    var leftDummyNode = new ListNode(null);</span><br><span class="line">    var rightDummyNode = new ListNode(null);</span><br><span class="line">    var left = leftDummyNode;</span><br><span class="line">    var right = rightDummyNode;</span><br><span class="line">    while (head) &#123;</span><br><span class="line">        if (head.val &lt; x) &#123;</span><br><span class="line">            left.next = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">            left = left.next;</span><br><span class="line">            left.next = null;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right.next = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">            right = right.next;</span><br><span class="line">            right.next = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left.next = rightDummyNode.next;</span><br><span class="line">    return leftDummyNode.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Sort-list"><a href="#Sort-list" class="headerlink" title="Sort list"></a>Sort list</h3><p>&emsp;&emsp; 归并排序。查找中间元素使用 fast slow point</p><p><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">var sortList = function(head) &#123;</span><br><span class="line">    if (head === null || head.next === null) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">     var mid = findMid(head);</span><br><span class="line">     var right = mid.next;</span><br><span class="line">     mid.next = null;</span><br><span class="line">     var leftSort = sortList(head);</span><br><span class="line">     var rightSort = sortList(right);</span><br><span class="line">     return mergeList(leftSort, rightSort);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function findMid(head) &#123; // 链表查找中间元素常用的方法是“快慢指针”。</span><br><span class="line">    if (!head) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    var slowPoint = head;</span><br><span class="line">    var fastPoint = head.next;</span><br><span class="line">    while (fastPoint &amp;&amp; fastPoint.next) &#123;</span><br><span class="line">        slowPoint = slowPoint.next;</span><br><span class="line">        fastPoint = fastPoint.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return slowPoint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mergeList(list1, list2) &#123;</span><br><span class="line">    var dummyNode = new ListNode(null);</span><br><span class="line">    var pre = dummyNode;</span><br><span class="line">    while (list1 &amp;&amp; list2) &#123;</span><br><span class="line">        if (list1.val &lt; list2.val) &#123;</span><br><span class="line">            pre.next = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pre.next = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    if (list1) &#123;</span><br><span class="line">        pre.next = list1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        pre.next = list2;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reorder-list"><a href="#Reorder-list" class="headerlink" title="Reorder list"></a>Reorder list</h3><p>&emsp;&emsp;从中间将链表分割，将后半部分链表翻转，之后再合并两个链表。</p><p><a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">var reorderList = function(head) &#123;</span><br><span class="line">    if (!head || !head.next) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    var mid = findMid(head);</span><br><span class="line">    var right = reverseList(mid.next);</span><br><span class="line">    mid.next = null;</span><br><span class="line">    var left = head;</span><br><span class="line">    var dummyNode = new ListNode(0);</span><br><span class="line">    var pre = dummyNode;</span><br><span class="line">    while (left) &#123;</span><br><span class="line">        pre.next = left;</span><br><span class="line">        left = left.next;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        if (right) &#123;</span><br><span class="line">            pre.next = right;</span><br><span class="line">            right = right.next;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyNode.next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function findMid(head) &#123;</span><br><span class="line">    if (!head || !head.next) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    var slow = head;</span><br><span class="line">    var fast = head.next;</span><br><span class="line">    while (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function reverseList(head) &#123;</span><br><span class="line">    var pre = null</span><br><span class="line">    while (head) &#123;</span><br><span class="line">        var next = head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Remove-nth-node-from-end-of-list"><a href="#Remove-nth-node-from-end-of-list" class="headerlink" title="Remove nth node from end of list"></a>Remove nth node from end of list</h3><p>&emsp;&emsp;使用fast slow point</p><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var removeNthFromEnd = function(head, n) &#123;</span><br><span class="line">    var dummyNode = new ListNode(0); // 使用dummyNode因为存在删除第一个元素的情况。</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    var slow = dummyNode;</span><br><span class="line">    var fast = head;</span><br><span class="line">    for (var i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while (fast) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    return dummyNode.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Linked-list-cycle"><a href="#Linked-list-cycle" class="headerlink" title="Linked list cycle"></a>Linked list cycle</h3><p>&emsp;&emsp;使用fast slow point</p><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var hasCycle = function(head) &#123;</span><br><span class="line">    if (!head || !head.next) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    var slow = head;</span><br><span class="line">    var fast = head.next;</span><br><span class="line">    while(fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        if (slow === fast) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Linked-list-cycle-II"><a href="#Linked-list-cycle-II" class="headerlink" title="Linked list cycle II"></a>Linked list cycle II</h3><p>&emsp;&emsp;使用fast slow point,假设链表头结点到入环点距离为a，则在快慢指针相遇后，慢指针再走a步到达入环点，这里使用一个临时指针从开始节点走，当临时指针和慢指针相遇的时候，即为入环点。属于特殊技巧，了解即可。</p><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var detectCycle = function(head) &#123;</span><br><span class="line">    if (!head || !head.next) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    var slow = fast = tmp = head;</span><br><span class="line">    while(fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        if (slow === fast) &#123; // 特殊技巧，了解即可。</span><br><span class="line">            while(tmp != slow) &#123;</span><br><span class="line">                tmp = tmp.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            return tmp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Merge-k-sorted-lists"><a href="#Merge-k-sorted-lists" class="headerlink" title="Merge k sorted lists"></a>Merge k sorted lists</h3><p>&emsp;&emsp;使用堆进行排序。之后用js实现一个简单堆之后再做。</p><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">leedcode地址</a></p><h3 id="Copy-list-with-random-pointer"><a href="#Copy-list-with-random-pointer" class="headerlink" title="Copy list with random pointer"></a>Copy list with random pointer</h3><p><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">leedcode地址</a></p><h3 id="Convert-sorted-array-to-binary-search-tree"><a href="#Convert-sorted-array-to-binary-search-tree" class="headerlink" title="Convert sorted array to binary search tree"></a>Convert sorted array to binary search tree</h3><ul><li>方法一：使用hash表。</li><li>方法二：一个比较巧妙的方法，不需要额外空间复杂度 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; null 转化成 1 -&gt; 1’ -&gt; 2 -&gt; 2’ -&gt; 3 -&gt; 3’ -&gt; 4 -&gt; 4’ -&gt; null</li></ul><p><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var sortedArrayToBST = function(nums) &#123;</span><br><span class="line">    if (nums === null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    return buildBst(nums, 0, nums.length - 1);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function buildBst(nums, start, end) &#123;</span><br><span class="line">    if (start &gt; end) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    var mid = Math.floor((start + end) / 2);</span><br><span class="line">    var node = new TreeNode(nums[mid]);</span><br><span class="line">    node.left = buildBst(nums, start, mid - 1);</span><br><span class="line">    node.right = buildBst(nums, mid + 1, end);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Convert-sorted-list-to-binary-search-tree"><a href="#Convert-sorted-list-to-binary-search-tree" class="headerlink" title="Convert sorted list to binary search tree"></a>Convert sorted list to binary search tree</h3><p><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var sortedListToBST = function(head) &#123;</span><br><span class="line">    if (head === null) &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125; else if (head.next === null) &#123;</span><br><span class="line">        return new TreeNode(head.val);</span><br><span class="line">    &#125; else if (head.next.next === null) &#123;</span><br><span class="line">        var node = new TreeNode(head.val);</span><br><span class="line">        node.right = new TreeNode(head.next.val);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">    var preMidNode = findPreMidNode(head);</span><br><span class="line">    var node = new TreeNode(preMidNode.next.val);</span><br><span class="line">    node.right = sortedListToBST(preMidNode.next.next);</span><br><span class="line">    preMidNode.next = null</span><br><span class="line">    node.left = sortedListToBST(head);</span><br><span class="line">    return node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function findPreMidNode(head) &#123;</span><br><span class="line">    var preMid = null;</span><br><span class="line">    var slow = head;</span><br><span class="line">    var fast = head.next;</span><br><span class="line">    while (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        preMid = slow;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return preMid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linked-List&quot;&gt;&lt;a href=&quot;#Linked-List&quot; class=&quot;headerlink&quot; title=&quot;Linked List&quot;&gt;&lt;/a&gt;Linked List&lt;/h1&gt;&lt;h3 id=&quot;Remove-duplicates-from-sorted
      
    
    </summary>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>binary-tree</title>
    <link href="http://yoursite.com/2019/06/17/binary-tree/"/>
    <id>http://yoursite.com/2019/06/17/binary-tree/</id>
    <published>2019-06-17T11:18:53.000Z</published>
    <updated>2019-06-17T12:43:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h2><p>&emsp;&emsp;解决二叉树常用的两种方法。</p><ul><li>遍历法(traverse),缺点是无法多线程。</li><li>分治法(divide conquer)。merge store 和 quick stort 都使用了分治法。</li></ul><h3 id="Maximum-depth-of-binary-tree"><a href="#Maximum-depth-of-binary-tree" class="headerlink" title="Maximum depth of binary tree"></a>Maximum depth of binary tree</h3><p>&emsp;&emsp;最基本的分治模板，分别计算左右子树，然后合并结果。</p><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var maxDepth = function(root) &#123;</span><br><span class="line">    if (root === null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    var leftMaxDepth = maxDepth(root.left);</span><br><span class="line">    var rightMaxDepth = maxDepth(root.right);</span><br><span class="line">    return Math.max(leftMaxDepth, rightMaxDepth) + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Balanced-binary-tree"><a href="#Balanced-binary-tree" class="headerlink" title="Balanced binary tree"></a>Balanced binary tree</h3><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var isBalanced = function(root) &#123;</span><br><span class="line">    var depth = balanceDepth(root);</span><br><span class="line">    return depth === -1 ? false : true;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function balanceDepth(root) &#123;</span><br><span class="line">    if (root === null) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    var leftBalanceDepth = balanceDepth(root.left);</span><br><span class="line">    var rightBalbanceDepth = balanceDepth(root.right);</span><br><span class="line">    if (leftBalanceDepth === -1 || rightBalbanceDepth === -1 || Math.abs(leftBalanceDepth - rightBalbanceDepth) &gt; 1) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.max(leftBalanceDepth, rightBalbanceDepth) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Binary-tree-maximum-path-sum"><a href="#Binary-tree-maximum-path-sum" class="headerlink" title="Binary tree maximum path sum"></a>Binary tree maximum path sum</h3><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var maxPathSum = function(root) &#123;</span><br><span class="line">    var &#123; singleSum, maxSum &#125; = getMathPath(root);</span><br><span class="line">    return maxSum;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">function getMathPath(root) &#123;</span><br><span class="line">    if (root === null) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            maxSum: -Infinity,</span><br><span class="line">            singleSum: 0,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    var leftMathPathObj = getMathPath(root.left);</span><br><span class="line">    var rightMathPathObj = getMathPath(root.right);</span><br><span class="line"></span><br><span class="line">    var value = root.val;</span><br><span class="line">    var singleSum = Math.max(leftMathPathObj.singleSum + value, rightMathPathObj.singleSum + value, 0);</span><br><span class="line">    var maxSum = Math.max(leftMathPathObj.maxSum, rightMathPathObj.maxSum, leftMathPathObj.singleSum + value + rightMathPathObj.singleSum);  </span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      maxSum,</span><br><span class="line">      singleSum,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lowest-common-ancestor-of-a-binary-tree"><a href="#Lowest-common-ancestor-of-a-binary-tree" class="headerlink" title="Lowest common ancestor of a binary tree"></a>Lowest common ancestor of a binary tree</h3><p>&emsp;&emsp;当root的左右节点查询p, q结果都不为空的时候，说明p和q一个在左节点，一个在右节点，root就是最近公共父节点。</p><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var lowestCommonAncestor = function(root, p, q) &#123;</span><br><span class="line">    if (!root || root === p || root === q) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    var left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    var right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    if (left &amp;&amp; right) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125; else if (!left) &#123;</span><br><span class="line">        return right;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Binary-tree-level-order-traversal"><a href="#Binary-tree-level-order-traversal" class="headerlink" title="Binary tree level order traversal"></a>Binary tree level order traversal</h3><p>&emsp;&emsp;数的宽度优先搜索是无法使用递归的，需要使用队列。js中，通过Array.shift实现出队。</p><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var levelOrder = function(root) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    var queue = [];</span><br><span class="line">    if (!root) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    queue.push(root);</span><br><span class="line">    while (queue.length &gt; 0) &#123;</span><br><span class="line">        var levelLength = queue.length;</span><br><span class="line">        var levelArray = [];</span><br><span class="line">        for (var i = 0; i &lt; levelLength; i++) &#123;</span><br><span class="line">            var node = queue.shift();</span><br><span class="line">            levelArray.push(node.val);</span><br><span class="line">            if (node.left) &#123;</span><br><span class="line">                queue.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.right) &#123;</span><br><span class="line">                queue.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(levelArray);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Validate-binary-search-tree"><a href="#Validate-binary-search-tree" class="headerlink" title="Validate binary search tree"></a>Validate binary search tree</h3><p>&emsp;&emsp;bst的中序遍历是升序的。</p><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var isValidBST = function(root) &#123;</span><br><span class="line">    var result = validBST(root);</span><br><span class="line">    return result.isBST;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">function validBST(root) &#123;</span><br><span class="line">    if (root === null) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            isBST: true,</span><br><span class="line">            min: Infinity,</span><br><span class="line">            max: -Infinity,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    var leftValid = validBST(root.left);</span><br><span class="line">    var rightValid = validBST(root.right);</span><br><span class="line">    var val = root.val;</span><br><span class="line">    if (leftValid.isBST &amp;&amp; rightValid.isBST &amp;&amp; val &gt; leftValid.max &amp;&amp; val &lt; rightValid.min) &#123;</span><br><span class="line">        var min = root.left ? leftValid.min : val;</span><br><span class="line">        var max = root.right ? rightValid.max : val;</span><br><span class="line">        return &#123;</span><br><span class="line">            isBST: true,</span><br><span class="line">            min,</span><br><span class="line">            max,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            isBST: false,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Binary-search-tree-iterator"><a href="#Binary-search-tree-iterator" class="headerlink" title="Binary search tree iterator"></a>Binary search tree iterator</h3><p>&emsp;&emsp;非递归实现递归可以考虑stack。</p><p><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var BSTIterator = function(root) &#123;</span><br><span class="line">    this.stack = [];</span><br><span class="line">    this.current = root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return the next smallest number</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">BSTIterator.prototype.next = function() &#123;</span><br><span class="line">    while(this.current !== null) &#123;</span><br><span class="line">        this.stack.push(this.current);</span><br><span class="line">        this.current = this.current.left</span><br><span class="line">    &#125;</span><br><span class="line">    this.current = this.stack.pop();</span><br><span class="line">    node = this.current;</span><br><span class="line">    this.current = this.current.right;</span><br><span class="line">    return node.val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @return whether we have a next smallest number</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">BSTIterator.prototype.hasNext = function() &#123;</span><br><span class="line">    if (this.current !== null || this.stack.length &gt; 0) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Delete-nod-in-a-bst"><a href="#Delete-nod-in-a-bst" class="headerlink" title="Delete nod in a bst"></a>Delete nod in a bst</h3><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var deleteNode = function(root, key) &#123;</span><br><span class="line">    if (root === null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    if (key &lt; root.val) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125; else if (key &gt; root.val) &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (root.left === null &amp;&amp; root.right === null) &#123;</span><br><span class="line">            return null</span><br><span class="line">        &#125; else if (root.left === null &amp;&amp; root.right !== null) &#123;</span><br><span class="line">            return root.right;</span><br><span class="line">        &#125; else if (root.right === null &amp;&amp; root.left !== null) &#123;</span><br><span class="line">            return root.left;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var pre = root.right;</span><br><span class="line">            var current = pre.left;</span><br><span class="line">            if (current === null) &#123;</span><br><span class="line">                pre.left = root.left</span><br><span class="line">                return pre;</span><br><span class="line">            &#125;</span><br><span class="line">            while (current.left !== null) &#123;</span><br><span class="line">                pre = current;</span><br><span class="line">                current = current.left;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.left = current.right;</span><br><span class="line">            current.left = root.left;</span><br><span class="line">            current.right = root.right;</span><br><span class="line">            return current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Binary-Tree&quot;&gt;&lt;a href=&quot;#Binary-Tree&quot; class=&quot;headerlink&quot; title=&quot;Binary Tree&quot;&gt;&lt;/a&gt;Binary Tree&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;解决二叉树常用的两种方法。&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>sorted-array</title>
    <link href="http://yoursite.com/2019/06/01/sorted-array/"/>
    <id>http://yoursite.com/2019/06/01/sorted-array/</id>
    <published>2019-06-01T02:06:42.000Z</published>
    <updated>2019-06-17T12:43:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sorted-Array"><a href="#Sorted-Array" class="headerlink" title="Sorted Array"></a>Sorted Array</h2><h3 id="Merge-sorted-array"><a href="#Merge-sorted-array" class="headerlink" title="Merge sorted array"></a>Merge sorted array</h3><p>&emsp;&emsp;主要思路：倒序从数组的尾部开始合并。</p><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var merge = function(nums1, m, nums2, n) &#123;</span><br><span class="line">  var latstIndex = m + n - 1;</span><br><span class="line">  var nums1LastIndex = m - 1;</span><br><span class="line">  var nums2LastIndex = n -1;</span><br><span class="line">  while(latstIndex &gt;= 0 &amp;&amp; nums2LastIndex &gt;=0) &#123;</span><br><span class="line">    if (nums1LastIndex === -1 || nums2[nums2LastIndex] &gt;= nums1[nums1LastIndex]) &#123;</span><br><span class="line">      nums1[latstIndex] = nums2[nums2LastIndex];</span><br><span class="line">      nums2LastIndex--;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      nums1[latstIndex] = nums1[nums1LastIndex];</span><br><span class="line">      nums1LastIndex--;</span><br><span class="line">    &#125;</span><br><span class="line">    latstIndex--;</span><br><span class="line">  &#125;</span><br><span class="line">  return nums1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Recover-rotated-dorted-array"><a href="#Recover-rotated-dorted-array" class="headerlink" title="Recover rotated dorted array"></a>Recover rotated dorted array</h3><p>&emsp;&emsp;Given a rotated sorted array, recover it to sorted array in-place</p><p>Example</p><p>[4, 5, 1, 2, 3] -&gt; [1, 2, 3, 4, 5]</p><p>使用O(1)的额外空间</p><p>三步翻转法。</p><p>[4, 5, 1, 2, 3] -&gt; [3, 2, 1, 5, 4] -&gt; [1, 2, 3, 5, 4] -&gt; [1, 2, 3, 4, 5]</p><h3 id="Median-of-two-sorted-arrays"><a href="#Median-of-two-sorted-arrays" class="headerlink" title="Median of two sorted arrays"></a>Median of two sorted arrays</h3><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">leedcode地址</a></p><p>解法一：</p><p>&emsp;&emsp;这个方法是我做这道题时候最先想到的方法。时间复杂度是O(min(m, n))并不能达到O(log(n + m))。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">var findMedianSortedArrays = function(nums1, nums2) &#123;</span><br><span class="line">    var length = nums1.length + nums2.length;</span><br><span class="line">    var half = Math.floor(length / 2);</span><br><span class="line">    var isJi = length % 2;</span><br><span class="line">    if (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">        var temp = nums1;</span><br><span class="line">        nums1 = nums2;</span><br><span class="line">        nums2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nums1.length === 0) &#123;</span><br><span class="line">        if (isJi) &#123;</span><br><span class="line">            return nums2[half];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return (nums2[half - 1] + nums2[half]) / 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (var i = -1; i &lt; nums1.length; i ++) &#123;</span><br><span class="line">        if (i === -1) &#123;</span><br><span class="line">            if (nums1[0] &gt;= nums2[half - 1]) &#123;</span><br><span class="line">                if (isJi) &#123;</span><br><span class="line">                    return nums2[half] &amp;&amp; (nums2[half] &lt; nums1[0]) ? nums2[half] : nums1[0];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return (nums2[half - 1] + (nums2[half] &amp;&amp; (nums2[half] &lt; nums1[0]) ? nums2[half] : nums1[0])) / 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (i == nums1.length - 1) &#123;</span><br><span class="line">            if (nums1[nums1.length - 1] &lt;= nums2[half - i - 1]) &#123;</span><br><span class="line">                if (isJi) &#123;</span><br><span class="line">                    return nums2[half - i - 1];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return (nums2[half - i -1] + (nums2[half - i - 2] &amp;&amp; (nums2[half - i - 2] &gt; nums1[i]) ? nums2[half - i - 2] : nums1[i])) / 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var a1 = nums1[i];</span><br><span class="line">            var a2 = nums1[i + 1];</span><br><span class="line">            var b1 = nums2[half - i - 2];</span><br><span class="line">            var b2 = nums2[half - i - 1];</span><br><span class="line">            if (a1 &lt;= b2 &amp;&amp; b1 &lt;= a2) &#123;</span><br><span class="line">                if (isJi) &#123;</span><br><span class="line">                    return a2 &amp;&amp; a2 &lt; b2 ? a2 : b2;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return ((a1 &gt; b1 ? a1 : b1) + (a2 &amp;&amp; a2 &lt; b2 ? a2 : b2)) / 2;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>解法二：</p><p>&emsp;&emsp;最终转换成了一个查到第k大的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var findMedianSortedArrays = function(nums1, nums2) &#123;</span><br><span class="line">    var len = nums1.length + nums2.length;</span><br><span class="line">    var halfLen = Math.floor(len / 2);</span><br><span class="line">    if (len % 2 === 0) &#123;</span><br><span class="line">        return (findKth(nums1, 0, nums2, 0, halfLen) + findKth(nums1, 0, nums2, 0, halfLen + 1)) / 2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return findKth(nums1, 0, nums2, 0, halfLen + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function findKth(nums1, start1, nums2, start2, k) &#123;</span><br><span class="line">    if(start1 &gt;= nums1.length) &#123;</span><br><span class="line">        return nums2[start2 + k -1];</span><br><span class="line">    &#125;</span><br><span class="line">    if (start2 &gt;= nums2.length) &#123;</span><br><span class="line">        return nums1[start1 + k - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    if (k === 1) &#123;</span><br><span class="line">        return Math.min(nums1[start1], nums2[start2]);</span><br><span class="line">    &#125;</span><br><span class="line">    var halfK = Math.floor(k / 2);</span><br><span class="line">    // 如果加halfK超过数据长度，表示half一定存在于另一个数组中，直接取Infinity表示最大值。</span><br><span class="line">    var key1 = start1 + halfK - 1 &lt; nums1.length ? nums1[start1 + halfK - 1] : Infinity;</span><br><span class="line">    var key2 = start2 + halfK - 1 &lt; nums2.length ? nums2[start2 + halfK - 1] : Infinity;</span><br><span class="line">    if (key1 &lt; key2) &#123;</span><br><span class="line">        return findKth(nums1, start1 + halfK, nums2, start2, k - halfK);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return findKth(nums1, start1, nums2, start2 + halfK, k - halfK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Sorted-Array&quot;&gt;&lt;a href=&quot;#Sorted-Array&quot; class=&quot;headerlink&quot; title=&quot;Sorted Array&quot;&gt;&lt;/a&gt;Sorted Array&lt;/h2&gt;&lt;h3 id=&quot;Merge-sorted-array&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>binary-search</title>
    <link href="http://yoursite.com/2019/05/30/binary-search/"/>
    <id>http://yoursite.com/2019/05/30/binary-search/</id>
    <published>2019-05-30T06:37:51.000Z</published>
    <updated>2019-06-16T08:10:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h1><p>&emsp;&emsp;这是一个关于二分查找相关的leedcode题的整理。</p><h3 id="First-bad-version"><a href="#First-bad-version" class="headerlink" title="First bad version"></a>First bad version</h3><p>&emsp;&emsp;很有趣的一道题，实际开发中我曾经遇到过类似的问题，当时傻傻的人工二分查找，感觉之后不会那么傻了，完全可以使用这种方式。典型的二分查找首个或者末个元素的题。</p><p><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var solution = function(isBadVersion) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param &#123;integer&#125; n Total versions</span><br><span class="line">     * @return &#123;integer&#125; The first bad version</span><br><span class="line">     */</span><br><span class="line">    return function(n) &#123;</span><br><span class="line">        var start = 1;</span><br><span class="line">        var end = n;</span><br><span class="line">        while(start + 1 &lt; end) &#123;</span><br><span class="line">            var mid = start + Math.floor((end - start) / 2);</span><br><span class="line">            if (isBadVersion(mid)) &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (isBadVersion(start)) &#123;</span><br><span class="line">            return start;</span><br><span class="line">        &#125;</span><br><span class="line">        if (isBadVersion(end)) &#123;</span><br><span class="line">            return end;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Search-first-amp-last-positon"><a href="#Search-first-amp-last-positon" class="headerlink" title="Search first&amp;last positon"></a>Search first&amp;last positon</h3><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">var searchRange = function(nums, target) &#123;</span><br><span class="line">    if (nums.length === 0) &#123;</span><br><span class="line">        return [-1, -1];</span><br><span class="line">    &#125;</span><br><span class="line">    var start = 0;</span><br><span class="line">    var end = nums.length - 1;</span><br><span class="line">    var firstIndex, endIndex, mid;</span><br><span class="line"></span><br><span class="line">    while(start + 1 &lt; end) &#123;</span><br><span class="line">        mid = start + Math.floor((end - start) / 2);</span><br><span class="line">        if (nums[mid] &gt;= target) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            start = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nums[start] === target) &#123;</span><br><span class="line">        firstIndex = start;</span><br><span class="line">    &#125; else if (nums[end] === target) &#123;</span><br><span class="line">        firstIndex = end;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [-1, -1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start = firstIndex;</span><br><span class="line">    end = nums.length - 1;</span><br><span class="line"></span><br><span class="line">    while(start + 1 &lt; end) &#123;</span><br><span class="line">        mid = start + Math.floor((end - start) / 2);</span><br><span class="line">        if (nums[mid] &lt;= target) &#123;</span><br><span class="line">            start = mid;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nums[end] === target) &#123;</span><br><span class="line">        endIndex = end;</span><br><span class="line">    &#125; else if (nums[start] === target) &#123;</span><br><span class="line">        endIndex = start;</span><br><span class="line">    &#125;</span><br><span class="line">    return [firstIndex, endIndex];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Search-insert-position"><a href="#Search-insert-position" class="headerlink" title="Search insert position"></a>Search insert position</h3><p>&emsp;&emsp;二分查找第一个大于或等于target的index 即可。</p><p><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var searchInsert = function(nums, target) &#123;</span><br><span class="line">    if (nums.length === 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var start = 0;</span><br><span class="line">    var end = nums.length - 1;</span><br><span class="line"></span><br><span class="line">    while(start + 1 &lt; end) &#123;</span><br><span class="line">        var mid = start + Math.floor((end - start) / 2);</span><br><span class="line">        if (nums[mid] &gt;= target) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            start = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nums[start] &gt;= target) &#123;</span><br><span class="line">        return start;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nums[end] &gt;= target) &#123;</span><br><span class="line">        return end;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Search-a-2D-matrix"><a href="#Search-a-2D-matrix" class="headerlink" title="Search a 2D matrix"></a>Search a 2D matrix</h3><p>&emsp;&emsp;可以将二维矩阵理解为一个特殊数据处理即可。</p><p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var searchMatrix = function(matrix, target) &#123;</span><br><span class="line">    var m = matrix.length;</span><br><span class="line">    if (m === 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    var n = matrix[0].length;</span><br><span class="line">    if (n === 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    var start = 0;</span><br><span class="line">    var end = m * n - 1;</span><br><span class="line">    while (start + 1 &lt; end) &#123;</span><br><span class="line">        var mid = start + Math.floor((end - start) / 2);</span><br><span class="line">        if (getMatrixValue(matrix, mid, n) === target) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (getMatrixValue(matrix, mid, n) &gt; target) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            start = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (getMatrixValue(matrix, start, n) === target || getMatrixValue(matrix, end, n) === target) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function getMatrixValue(matrix, index, n) &#123;</span><br><span class="line">    return matrix[Math.floor(index / n)][index % n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Search-a-2D-Matrix-II"><a href="#Search-a-2D-Matrix-II" class="headerlink" title="Search a 2D Matrix II"></a>Search a 2D Matrix II</h3><p>&emsp;&emsp;思路是从左下角开始找起，如果元素大于target，上移，如果小于target，右移，相等直接返回true。</p><p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var searchMatrix = function(matrix, target) &#123;</span><br><span class="line">    var m = matrix.length;</span><br><span class="line">    if (m === 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    var n = matrix[0].length;</span><br><span class="line">    if (n === 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var row = m - 1;</span><br><span class="line">    var col = 0;</span><br><span class="line">    while (row &gt;=0 &amp;&amp; col &lt; n) &#123;</span><br><span class="line">        if (matrix[row][col] === target) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (matrix[row][col] &gt; target) &#123;</span><br><span class="line">            row--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            col++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Find-minimum-in-rotated-sorted-array"><a href="#Find-minimum-in-rotated-sorted-array" class="headerlink" title="Find minimum in rotated sorted array"></a>Find minimum in rotated sorted array</h3><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var findMin = function(nums) &#123;</span><br><span class="line">    if (nums.length === 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    var start = 0;</span><br><span class="line">    var end = nums.length - 1;</span><br><span class="line">    while (start + 1 &lt; end) &#123;</span><br><span class="line">        var mid = start + Math.floor((end - start) / 2);</span><br><span class="line">        if (nums[mid] &lt; nums[end]) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            start = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nums[start] &lt;= nums[end]) &#123;</span><br><span class="line">        return nums[start];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return nums[end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Find-minimum-in-rotated-sorted-array-II"><a href="#Find-minimum-in-rotated-sorted-array-II" class="headerlink" title="Find minimum in rotated sorted array II"></a>Find minimum in rotated sorted array II</h3><p>&emsp;&emsp;这个需要通过黑盒测试证明时间复杂度是O(n)，比如针对[1, 1, 0, 1, 1, ,1 ,1]就无法使用二分法查找最小值。</p><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">leedcode地址</a></p><h3 id="Search-in-rotated-sorted-array"><a href="#Search-in-rotated-sorted-array" class="headerlink" title="Search in rotated sorted array"></a>Search in rotated sorted array</h3><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array" target="_blank" rel="noopener">leedcode地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var search = function(nums, target) &#123;</span><br><span class="line">    var start = 0;</span><br><span class="line">    var end = nums.length - 1;</span><br><span class="line">    while (start + 1 &lt; end) &#123;</span><br><span class="line">        var mid = start + Math.floor((end - start) / 2);</span><br><span class="line">        if (nums[mid] === target) &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((nums[start] &lt;= target &amp;&amp; target &lt; nums[mid]) || (nums[start] &gt;= nums[mid] &amp;&amp; (nums[start] &lt;= target || target &lt; nums[mid]))) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; else if ((nums[mid] &lt; target &amp;&amp; target &lt;= nums[end] ) || (nums[mid] &gt;= nums[end] &amp;&amp; (nums[mid] &lt; target || target &lt;= nums[end]))) &#123;</span><br><span class="line">            start = mid;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            start = end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nums[start] === target) &#123;</span><br><span class="line">        return start;</span><br><span class="line">    &#125;</span><br><span class="line">    if (nums[end] === target) &#123;</span><br><span class="line">        return end;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Search-in-rotated-sorted-array-II"><a href="#Search-in-rotated-sorted-array-II" class="headerlink" title="Search in rotated sorted array II"></a>Search in rotated sorted array II</h3><p>&emsp;&emsp;这个也可以依据黑盒算法证明无法通过二分查找计算结果。</p><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii" target="_blank" rel="noopener">leedcode地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Binary-Search&quot;&gt;&lt;a href=&quot;#Binary-Search&quot; class=&quot;headerlink&quot; title=&quot;Binary Search&quot;&gt;&lt;/a&gt;Binary Search&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;这是一个关于二分查找相关的l
      
    
    </summary>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>subsets</title>
    <link href="http://yoursite.com/2019/05/19/subsets/"/>
    <id>http://yoursite.com/2019/05/19/subsets/</id>
    <published>2019-05-19T08:48:40.000Z</published>
    <updated>2019-06-16T08:10:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>排列组合问题的一般解法就是递归。</p><p>求所有方案的题，90%是搜索问题，搜索问题90%是问递归，搜索问题100% 是排列组合问题。</p><h3 id="subsets"><a href="#subsets" class="headerlink" title="subsets"></a>subsets</h3><p><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">leedcode-subsets</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var subsets = function(nums) &#123;</span><br><span class="line">    var results = [];</span><br><span class="line">    var list = [];</span><br><span class="line">    subsetsHelper(results, list, nums, 0);</span><br><span class="line">    return results;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function subsetsHelper(results, list, nums, position) &#123;</span><br><span class="line">    // 此处需要用list.concat()对数据进行克隆。</span><br><span class="line">    results.push(list.concat());</span><br><span class="line">    for (var i = position; i &lt; nums.length; i++) &#123;</span><br><span class="line">        list.push(nums[i]);</span><br><span class="line">        subsetsHelper(results, list, nums, i + 1);</span><br><span class="line">        list.pop(list.length - 1); // 回溯。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法使用了深度优先搜索的方式。同时用到了回溯。可以使用避免回溯，但是会增加空间复杂度。</p><h3 id="unique-subsets"><a href="#unique-subsets" class="headerlink" title="unique subsets"></a>unique subsets</h3><p><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">subsets-ii</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var subsetsWithDup = function(nums) &#123;</span><br><span class="line">    var results = [];</span><br><span class="line">    var list = [];</span><br><span class="line">    nums = nums.sort();</span><br><span class="line">    subsetsHelper(results, list, nums, 0);</span><br><span class="line">    return results;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function subsetsHelper(results, list, nums, position) &#123;</span><br><span class="line">    // 此处需要用list.concat()对数据进行克隆。</span><br><span class="line">    results.push(list.concat());</span><br><span class="line">    for (var i = position; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (i !== position &amp;&amp; nums[i] === nums[i - 1]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        list.push(nums[i]);</span><br><span class="line">        subsetsHelper(results, list, nums, i + 1);</span><br><span class="line">        list.pop(list.length - 1); // 回溯。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;排列组合问题的一般解法就是递归。&lt;/p&gt;
&lt;p&gt;求所有方案的题，90%是搜索问题，搜索问题90%是问递归，搜索问题100% 是排列组合问题。
      
    
    </summary>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>strStr</title>
    <link href="http://yoursite.com/2019/05/19/strStr/"/>
    <id>http://yoursite.com/2019/05/19/strStr/</id>
    <published>2019-05-19T07:55:33.000Z</published>
    <updated>2019-06-16T08:10:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="strStr"><a href="#strStr" class="headerlink" title="strStr"></a>strStr</h2><p>最近在看九章算法，最先提到的就是strStr问题，针对这个问题，记录自己学到的一些东西。</p><p>implement strstr 问题地址：</p><ul><li><a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="noopener">leetcode</a></li><li><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">leetcode-cn</a></li></ul><h3 id="双循环实现"><a href="#双循环实现" class="headerlink" title="双循环实现"></a>双循环实现</h3><p>针对strStr 问题，比较简单的实现就是双循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var strStr = function(haystack, needle) &#123;</span><br><span class="line">    if (haystack === null || needle === null || haystack.length &lt; needle.length) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    var i, j;</span><br><span class="line">    for (i = 0; i &lt; haystack.length - needle.length + 1; i++) &#123;</span><br><span class="line">        for (j = 0; j &lt; needle.length; j++) &#123;</span><br><span class="line">            if (haystack[i + j] !== needle[j]) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (j === needle.length) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="kmp-算法"><a href="#kmp-算法" class="headerlink" title="kmp 算法"></a>kmp 算法</h3><p>kmp 算法应该是解决字符串匹配最常用的算法。</p><p><a href="https://zh.wikipedia.org/zh-hans/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">kmp-维基百科</a></p><p>kmp 代码实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">var strStr = function(haystack, needle) &#123;</span><br><span class="line">    var next = getNext(needle);</span><br><span class="line">    var i = 0;</span><br><span class="line">    var j = 0;</span><br><span class="line">    while (i &lt; haystack.length &amp;&amp; j &lt; needle.length) &#123;</span><br><span class="line">        if (j == -1 || haystack[i] == needle[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (j == needle.length) &#123;</span><br><span class="line">        return i - j;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function getNext(str) &#123;</span><br><span class="line">    var next = [];</span><br><span class="line">    next[0] = -1;</span><br><span class="line"></span><br><span class="line">    var i = 0;</span><br><span class="line">    var j = -1;</span><br><span class="line">    while(i &lt; str.length - 1) &#123;</span><br><span class="line">        if (j == -1 || str[i] == str[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;strStr&quot;&gt;&lt;a href=&quot;#strStr&quot; class=&quot;headerlink&quot; title=&quot;strStr&quot;&gt;&lt;/a&gt;strStr&lt;/h2&gt;&lt;p&gt;最近在看九章算法，最先提到的就是strStr问题，针对这个问题，记录自己学到的一些东西。&lt;/p&gt;
&lt;p&gt;im
      
    
    </summary>
    
      <category term="九章算法" scheme="http://yoursite.com/categories/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>为什么精英都是时间控笔记</title>
    <link href="http://yoursite.com/2019/05/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B2%BE%E8%8B%B1%E9%83%BD%E6%98%AF%E6%97%B6%E9%97%B4%E6%8E%A7%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/05/12/为什么精英都是时间控笔记/</id>
    <published>2019-05-12T10:40:54.000Z</published>
    <updated>2019-06-16T08:10:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>  《为什么精英都是时间控》是在最近的一次面试中，候选人提及的书籍。后来我在微信读书中搜到了这本书。书的作者是<strong>桦泽紫苑</strong>，看完之后感触良多。</p><h3 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h3><ul><li>工作可以分为两种：一种需要高度专注力的工作；另一种则不需要太强的专注力。以专注力为中心对时间分配进行思考，专注性工作应该放到上午来做。</li><li>作者认为时间的计算不是一维的，要和专注力结合，是二维的。</li><li><strong>不管发生什么，不要压缩“睡眠时间”</strong></li><li>自由时间要用于提高自己的工作能力和技巧，要进行自我投资。</li><li><strong>最终目标“为了快乐”而使用时间。</strong></li></ul><h3 id="第一章-提高专注力的方法"><a href="#第一章-提高专注力的方法" class="headerlink" title="第一章 提高专注力的方法"></a>第一章 提高专注力的方法</h3><ul><li>15·45·90 法则</li><li>杂念排除法<ul><li>外物引起的杂念，保证办公桌整整齐齐</li><li>思考引起的杂念，把心里惦记的事情写下来，稍后处理（确定开始处理时间而不是截止时间）</li><li>时间限制工作术。不要有做不完加班的思想，限制自己在下班之前把工作做完。</li></ul></li></ul><h3 id="第二章-充分利用早上的大好时光"><a href="#第二章-充分利用早上的大好时光" class="headerlink" title="第二章 充分利用早上的大好时光"></a>第二章 充分利用早上的大好时光</h3><ul><li>早上是大脑的黄金时间。</li><li>起床术<ul><li>早上冲个澡，热水澡能够提高体温，加快心跳、呼吸速度。让交感神经占据主导地位。</li><li>开着窗帘睡觉。早上的阳光可以促进脑内一种名叫血清素（控制我们睡眠和清醒）的神经递质的分泌。可以醒来后睁眼躺5分钟。</li><li>有节奏的运动，运动也可以促进血清素的分泌。</li><li>早上不要“看电视”。</li></ul></li><li>上班第一件事是对一天的工作时间进行规划。</li></ul><h3 id="第三章-午后重启术"><a href="#第三章-午后重启术" class="headerlink" title="第三章 午后重启术"></a>第三章 午后重启术</h3><ul><li>外出吃早餐，有助于我们提高血清的活力。场所的改变也可以激发人脑内“场所神经元”的活性。</li><li>午睡（20-30分钟）。NASA 研究表明，中午进行26分钟的小睡，可以让下午的工作效率提高34%、专注力提高54%。 <strong>午睡也可以降低死亡率</strong>。睡前可以喝杯咖啡，咖啡因会在30分钟后发挥作用。</li><li>重启工作术<ul><li>运动</li><li>更换场所</li><li>穿插工作</li><li>小憩 5分钟</li></ul></li></ul><h3 id="第四章-夜晚-amp-睡眠重启术"><a href="#第四章-夜晚-amp-睡眠重启术" class="headerlink" title="第四章 夜晚&amp;睡眠重启术"></a>第四章 夜晚&amp;睡眠重启术</h3><ul><li>运动，不要在睡前三小时内运动。</li><li>不要让压力和疲惫过夜。</li><li>睡前2小时适宜享受放松，看看书，听听音乐。睡前不能吃东西，会导致血糖升高，生长激素会减少。</li><li>睡前15分钟是记忆黄金时间。</li><li>周末不要刻意补充睡眠。</li></ul><p><img src="/2019/05/12/为什么精英都是时间控笔记/完美的一天.jpeg" alt="根据脑科学原理设计的最完美的一天"></p><h3 id="第五章-创造时间工作术"><a href="#第五章-创造时间工作术" class="headerlink" title="第五章 创造时间工作术"></a>第五章 创造时间工作术</h3><ul><li>For You 工作术，ASAP。守时，提前30分钟行动。</li><li>趁现在工作术<ul><li>2分钟判断（如果两分钟就可以做完，立即做而不是推迟）。</li><li>30秒决断术，“快棋理论”</li><li>暂时无法决断的事，判断为“未决”留给日后决断。</li><li>不是“到什么时候为止”而是“什么时间做”</li><li>立刻就预约</li></ul></li><li>并行工作术<ul><li>不要一边…一边…</li><li>读书，读书要有输出</li><li>耳学</li><li>思考</li></ul></li></ul><h3 id="第六章-自我投资-amp-自我更新"><a href="#第六章-自我投资-amp-自我更新" class="headerlink" title="第六章 自我投资&amp;自我更新"></a>第六章 自我投资&amp;自我更新</h3><ul><li>自由时间不要用于工作。不追求量，提高质。</li><li>投资自己。</li><li>主动性娱乐。</li></ul><h2 id="读后整理的个人的时间计划"><a href="#读后整理的个人的时间计划" class="headerlink" title="读后整理的个人的时间计划"></a>读后整理的个人的时间计划</h2><p>打开窗帘睡觉</p><p>8:00 ~ 8:30 起床</p><ul><li>洗漱，如果没有精神可以洗个热水澡。</li><li>早饭时间，学会慢速咀嚼。</li><li>如果是周末，可以考虑下楼散散步。散步的时候可以规划一下一天的计划。</li></ul><p>9:00 ~ 10:00 上班路途中。（自我投资，并行工作术）</p><ul><li>读书（微信读书，或者纸质书）</li><li>耳学 (学习英语，或者听听喜马拉雅的讲座)</li><li>思考</li></ul><p>10:00 确定一天的计划。开始专注性工作。</p><p>12:00 外出吃饭。<br>13:00 ~ 13:30 冲杯咖啡，午睡。</p><p>18:30 做杯冷萃咖啡明天喝<br>19:00 准时下班。</p><p>20:00 ~ 21:00 有氧运动（波比跳或者跑步，周一和周五休息）<br>21:00 ~ 22:30 学习时间（大数据方面）<br>22:30 ~ 23:30 一小时看看书<br>22:30 ~ 24:00 睡前背单词。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;  《为什么精英都是时间控》是在最近的一次面试中，候选人提及的书籍。后来我在微信读书中搜到了这本书。书的作者是&lt;strong&gt;桦泽紫苑&lt;/s
      
    
    </summary>
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>创建高性能索引</title>
    <link href="http://yoursite.com/2018/11/11/%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2018/11/11/创建高性能索引/</id>
    <published>2018-11-11T15:37:25.000Z</published>
    <updated>2019-06-16T08:10:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高性能索引"><a href="#高性能索引" class="headerlink" title="高性能索引"></a>高性能索引</h1><hr><p>&emsp;&emsp;首先申明，本文章内容绝大数知识点来自于《高性能mysql》一书，个人只是做一个总结用于以后查看，如果希望全面学习，可以读一下《高性能mysql》，很经典的书。</p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><hr><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>&emsp;&emsp;B-Tree 和 B+Tree 的原理此处就不再论述，如果感兴趣，推荐《数据结构与算法分析》这本书。</p><p>&emsp;&emsp;假设有如下数据表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE People (</span><br><span class="line">    last_name varchar(50) not null,</span><br><span class="line">    first_name varchar(50) not null,</span><br><span class="line">    dob date not null,</span><br><span class="line">    gender enum(&apos;m&apos;, &apos;f&apos;) not null,</span><br><span class="line">    key(last_name, first_name, dob)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;索引对如下的查询有效。</p><ul><li>全职匹配 <blockquote><p>select * from People where last_name = ‘liu’ and first_name = ‘lei’ and dob = ‘1994-05-05’;</p></blockquote></li><li>匹配最左前缀<blockquote><p>select * from People where last_name = ‘liu’;</p></blockquote></li><li>匹配列前缀<blockquote><p>select * from People where last_name like ‘l%’; (注意此处like %l%并不会使用索引，因为MySQL并不能优化为范围查询。)</p></blockquote></li><li>匹配范围值<blockquote><p>select * from People where last_name between ‘liu’ and ‘wang’;</p></blockquote></li><li>精确匹配某一列并范围匹配另外一列<blockquote><p>select * from People where last_name = ‘liu’ and first_name like ‘l%’;</p></blockquote></li><li>只访问索引的查询<blockquote><p>select last_name from People where last_name = ‘liu’; (<strong>覆盖索引</strong>，后边会讲)</p></blockquote></li></ul><p>&emsp;&emsp;因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于ORDER BY 操作（按顺序查找）。</p><p>&emsp;&emsp; B-Tree 索引的限制</p><ul><li>如果不按照索引的最左列开始查找，则无法使用索引。<blockquote><p>select * from People where first_name = ‘lei’; (类似的，last_name like ‘$i’ 也是无法使用索引的)。</p></blockquote></li><li>不能跳过索引中的列。<blockquote><p>select * from People where last_name = ‘liu’ and dob = ‘1994-05-05’;(可以使用索引，但是只能使用索引的第一列。)</p></blockquote></li><li>如果查询中的某个列的范围查询，则其右边的所有列都无法使用索引优化查询。<blockquote><p>select * from People where last_name = ‘liu’ and first_name like ‘l%’ and dob = ‘1994-05-05’;(只能使用索引的前两列)</p></blockquote></li></ul><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>&emsp;&emsp;哈希索引（hash index) 基于哈希表实现，只有精确匹配索引所有列的查询才有效。在MySQL中，只有Memory引擎显式支持哈希索引。因为哈希索引的一些限制，我认为哈希索引的使用场景有限，不做过多描述。</p><p>&emsp;&emsp;哈希索引的限制：</p><ul><li>哈希索引只包含哈希值和行指针，不存储字段值，所以不能使用索引中的值来避免读取行。</li><li>哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。</li><li>哈希索引也无法支持部分索引列匹配查找。</li><li>哈希索引只支持等值比较查询，包括 =、in()。也不支持任何范围查询。</li><li>如果哈希冲突很多的话，一些索引维护的代价会很高。</li></ul><p>&emsp;&emsp;InnoDB引擎有一个特殊的功能叫做“自适应哈希索引”</p><p>&emsp;&emsp;创建自定义哈希索引。在B-Tree上创建一个伪哈希索引。例如需要存储大量的url，并需要根据url进行搜索查找。如果使用B-Tree来存储url，存储内容就会很大，因为url本身都很长。会有如下查询</p><pre><code>&gt; select id from url where url = &quot;https://www.mysql.com&quot;;</code></pre><p>&emsp;&emsp;若删除原来列上的索引，新增一个被索引的url_crl列，使用crc32做哈希，就可以使用下面的方式查询。</p><pre><code>&gt; select id from url where url = &quot;https://www.mysql.com&quot; and url_crc=CRC32(&quot;https://www.mysql.com&quot;);</code></pre><h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><p>&emsp;&emsp;三大优点</p><pre><code>1. 索引大大减少了服务器需要扫描的数据量。2. 索引可以帮助服务器避免排序和临时表。3. 索引可以将随机I/O变成顺序I/O。</code></pre><p>&emsp;&emsp;三星索引：索引将相关记录放到一起获得一星；如果索引中的数据顺序和查找中的顺序一致则获得一星；如果索引中包含了查询中需要的全部列则获得一星。</p><h2 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h2><h3 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h3><p>&emsp;&emsp;独立的列指索引列不能是表达式的一部分，也不能是函数的参数。</p><h3 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h3><p>&emsp;&emsp;有时候需要索引很长的字符串，这会让索引变的大且慢。一个策略是通过模拟哈希索引。还可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。 索引的选择性是指，不重复的索引值（也称为基数，cardinality, 通过show index from table可以看到）和标的记录总数（#T)的比值，范围从 1/#T 到 1之间。</p><blockquote><p>创建前缀索引。<br><br>alter table tab add key ( column(7) );</p></blockquote><h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><ul><li>在多个列上建立独立的单列索引大部分情况下不能提高MySQL的查询性能。</li><li>MySQL在5.0之后引入了一个叫‘索引合并’的策略。在MySQL5.0和更新的版本中，查询能够同时使用两个单列索引进行扫描，并将结果进行合并。这种算法有三种变种：OR条件的联合（union），and条件的相交（intersection），组合前两种情况的联合及相交。</li><li>索引合并策略有时候是一种优化的结果，但实际上更多说明表上建立的索引很糟糕。</li></ul><h3 id="选择合适的索引顺序"><a href="#选择合适的索引顺序" class="headerlink" title="选择合适的索引顺序"></a>选择合适的索引顺序</h3><p>&emsp;&emsp;对于如何选择索引列的顺序有一个经验法则：将选择性最高的列放到索引最前列。</p><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><ul><li>聚簇索引是一种数据存储方式。当表有聚簇索引时，它的数据行实际上存放在索引的叶子页（leaf page）中。</li><li>因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引（覆盖索引可以模拟多个聚簇索引的情况）。</li><li>Innodb 通过主键聚集数据，如果没有定义主键，Innodb 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。</li><li>聚簇索引的优点<ol><li>可以把相关数据保存到一起。</li><li>访问数据更快。</li><li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li></ol></li><li>聚簇索引的缺点<ol><li>插入速度严重依赖于插入顺序。按照主键的顺序插入式加载数据到innodb表中速度最快的方式。 从性能角度考虑，使用uuid来作为聚簇索引会很糟糕。</li><li>更新聚簇索引的代价很高，因为会强制InnoDB将每个更新的行移动到新的位置。 个人认为在mysql中更新主键是超级傻的事情。</li><li>可能面临‘页分裂（page split)’的问题。</li><li>聚簇索引可能导致全表扫描变慢。</li><li>二级索引（非聚簇索引）可能比想象中的要更大，因为二级索引的叶子节点包含了行的主键值。</li><li>二级索引访问需要两次索引查找。</li></ol></li></ul><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><ul><li>如果一个索引包含所有需要查询的字段，我们就称之为‘覆盖索引’。</li><li>EXPLAIN 的 extra 列中的 “Using index” 表明了 索引覆盖查询。</li><li>无法使用覆盖索引的情况<ol><li>没有索引能覆盖查询。</li><li>MySQL 不能在索引中执行like操作。</li></ol></li><li><strong>延迟关联</strong>（deferred join). 派生查询使用覆盖索引查询主键，通过关联查询所需的列。很棒的一个优化策略。<blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; select * from products join (</span><br><span class="line">&gt;   select prod_id from products</span><br><span class="line">&gt;   where actior = &apos;liulei&apos; and title like &apos;%title%&apos;;</span><br><span class="line">&gt;) as t1 on (t1.prod_id = products.prod_id)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><h3 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h3><ul><li>MySQL有两种方式可以生成有序的结果：通过排序操作；或者按照索引顺序扫描。</li><li>如果EXPLAIN出来的type列的值为“index”，则说明MySQL使用了索引扫描排序。</li><li>只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向（倒序或者正序）都一样时，MySQL才能使用索引来对结果做排序。</li></ul><h3 id="避免多个范围条件"><a href="#避免多个范围条件" class="headerlink" title="避免多个范围条件"></a>避免多个范围条件</h3><ul><li>从EXPLAN的输出很难区分MySQL是要查询范围值，还是查询列表值。EXPLAIN使用同样的词‘range’ 来描述这两种情况。MySQL会把下边两个查询都当做 “range” 类型。<blockquote><p>explain select actor_id from actor where actor_id &gt; 45;</p></blockquote></li></ul><blockquote><p>explain select actor_id from actor where actor_id in (1,4,9);</p></blockquote><ul><li>在我们看来，第二个查询就是多个等值条件查询。 对于范围条件查询，MySQL无法再使用范围列后面的其他索引列了，但是对于“多个等值条件查询” 则没有这个限制。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;高性能索引&quot;&gt;&lt;a href=&quot;#高性能索引&quot; class=&quot;headerlink&quot; title=&quot;高性能索引&quot;&gt;&lt;/a&gt;高性能索引&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;首先申明，本文章内容绝大数知识点来自于《高性能mysql》一书，个人只是做一个总结
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="性能/优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>mysql查询优化</title>
    <link href="http://yoursite.com/2018/10/21/mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/10/21/mysql查询优化/</id>
    <published>2018-10-21T14:48:05.000Z</published>
    <updated>2019-06-16T08:10:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-查询优化策略"><a href="#Mysql-查询优化策略" class="headerlink" title="Mysql 查询优化策略"></a>Mysql 查询优化策略</h1><hr><p>&emsp;&emsp;这篇文章是自己对 <strong><em>《High Performance Mysql》</em></strong> 第六章 <strong>查询性能优化</strong> 的一个总结，其实网络上很多关于mysql查询优化的文章，然而这些文章中的大部分知识都是来自于《High Performance Mysql》这本经典之作。如果希望能够更好了解mysql相关知识，不妨买本《High Performance Mysql》。</p><p><img src="/2018/10/21/mysql查询优化/high_performance_mysql.jpg" alt="《High Performance Mysql》"></p><p>&emsp;&emsp; <strong><em>查询优化，索引优化，库表结构的优化需要齐头并进，一个不落</em></strong> 。之后会写文章记录如何为高效的查询设计表和索引。</p><h2 id="慢查询基础"><a href="#慢查询基础" class="headerlink" title="慢查询基础"></a>慢查询基础</h2><p>&emsp;&emsp;在编写快速的查询之前，需要清楚一点，真正重要的是响应时间。了解查询的生命周期，清楚查询的时间消耗情况对于优化查询有很大的意义。</p><p>&emsp;&emsp;<font color="red">查询性能低下最基本的原因是访问的数据太多</font>。对于低效的查询，下面两个步骤来分析总是有效的。</p><blockquote><ol><li>确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问太多的列。</li><li>确认 MySQL 服务器层是否在分析大量超过需要的数据行。</li></ol></blockquote><ul><li>避免查询不需要的记录</li><li>每次看到 <strong>SELECT *</strong> 的时候要用怀疑的眼光审视。取出全部的列，会让优化器无法完成索引覆盖扫描这类优化，还会带来额外的I/O、内存和CPU的消耗。一些DBA是禁止 <strong>SELECT *</strong> 这类写法的。当然 <strong>SELECT *</strong> 某些时候可以简化开发，如果清楚这样做的性能影响，这种做法是值得考虑的。</li><li>对于MySQL，最简单的衡量查询开销的三个指标如下：<ol><li>响应时间</li><li>扫描的行数</li><li>返回的行数</li></ol></li><li>在 EXPLAIN 语句中的 type 类型反应了访问类型。（会有专门文章描述 EXPLAIN 的使用）。</li><li>一般MySQL 使用三种方式应用where条件吗，从好到坏依次是：<ol><li>在索引中使用where条件来过滤不匹配的记录。这是在存储引擎层完成的。</li><li>使用索引覆盖扫描（在 Extra 列中出现了 Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务层完成的，但无需再回表查询记录。</li><li>从数据表中返回数据，然后过滤不满足条件的记录（在 Extra 列中出现了 Using where）。这在MySQL服务层完成，MySQL需要先从数据表读出记录然后过滤。</li></ol></li><li>如果发现查询需要扫描大量的数据但是只返回少量的行，那么通常可以通过下面的技巧去优化它。<ol><li>使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎就无需回表获取对应的行就可以返回结果了。</li><li>改变表结构。例如使用单独的汇总表。</li><li>重写这个复杂的查询，让MySQL 优化器能够以更优化的方式执行这个查询。（这篇文章的重点）</li></ol></li><li>重构查询方式<ol><li>能否把一个复杂的查询拆分成多个简单的查询</li><li>分解关联查询。有如下优势：<ul><li>让缓存更高效。</li><li>查询分解后，执行单个查询可以减少锁竞争。</li><li>在应用层关联，可以很容易的对数据库进行拆分，更容易做到高性能和可扩展。</li><li>查询本身的效率也可能会有所提升。</li><li>可以减少冗余记录的查询。</li><li>更进一步，这样做相当于在应用中实现了哈希关联。某些场景哈希关联的效率要高很多。</li></ul></li></ol></li></ul><h2 id="mysql查询的原理"><a href="#mysql查询的原理" class="headerlink" title="mysql查询的原理"></a>mysql查询的原理</h2><hr><p>下图显示了查询的执行路径：</p><blockquote><ol><li>客户端发送一条查询给服务器。</li><li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果，否则进入下一阶段。</li><li>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。</li><li>MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。</li><li>将结果返回给客户端。</li></ol></blockquote><p><img src="/2018/10/21/mysql查询优化/query_plan.png" alt="查询执行路径"></p><p>&emsp;&emsp;如果你google过sql执行原理相关的文章，那么上边的内容不会陌生，之后我会记录一些个人的理解。</p><ol><li>客户端发送一条查询给服务器。<ul><li>客户端发送数据包到服务端是有数量限制的。 <strong>MySQL server has gone away</strong> 错误可能的原因就是传输的数据量太大。 可以通过 <strong>show variables like “max_allowed_packet”</strong> 命令查看服务器允许传送的最大数据（单位是byte）。可以通过 <strong>set global max_allowed_packet = 2*10*1024*1024</strong> 进行修改。</li><li>查询状态，对于一个MySQL连接或者说一个线程，任何时刻都有一个状态，该状态表示MySql当前正在做什么。 可以使用 <strong>SHOW FULL PROCESSLIST</strong> 命令。<ul><li>Sleep  线程正在等待客户端，以向它发送一个新语句</li><li>Query  线程正在执行查询或往客户端发送数据</li><li>Locked  该查询被其它查询锁定</li><li>Copying to tmp table on disk  临时结果集合大于tmp_table_size。线程把临时表从存储器内部格式改变为磁盘模式，以节约存储器</li><li>Sending data  线程正在为SELECT语句处理行，同时正在向客户端发送数据</li><li>Sorting for group  线程正在进行分类，以满足GROUP BY要求</li><li>Sorting for order  线程正在进行分类，以满足ORDER BY要求</li></ul></li></ul></li><li>查询缓存（Query cache）。MySQL的查询缓存是通过一个对大小写敏感的哈希查找实现的。查询和缓存中的查询即使只有一个字节不同，那也不会匹配缓存。 因为一些原因，很多情况是会关闭MySQL的Query cache的，原因可以看<a href="http://imysql.com/2014/09/05/mysql-faq-why-close-query-cache.shtml" target="_blank" rel="noopener"><font color="#3399ea">这里</font></a>。可以通过 <strong>set global query_cache_tyep=0</strong> 和 <strong>set global query_cache_size=0</strong> 关闭 Query cache。同时，在存储引擎层面也会有自己的缓存策略。</li><li><p>查询优化处理</p><ul><li>语法解析器和优化器，MySQL通过关键字将SQL进行解析，生成一颗对应的“解析树”。</li><li>查询优化。 MySQL使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划的成本，并选择其中成本最小的一个（其实经常mysql没有选择最优的执行计划，因此需要我们的优化）。可以通过 <strong>show status like ‘Last_query_cost’</strong> 来得知MySQL计算的当前查询的成本。有很多原因会导致MySQL优化器选择错误的执行计划，这里就不罗列了，如果想要了解不妨买本《High Performance MySQL》细读一下。</li></ul><ul><li>MySQL能够处理的优化类型<ul><li>重新定义关联表的顺序。（也因为这点，关联查询结果的顺序是不定的。）</li><li>将外连接转化成内连接。</li><li>使用等价变换规则。</li><li>优化count，min 和 max。</li><li>预估并转化为常数表达式。</li><li>覆盖索引扫描。</li><li>子查询优化。</li><li>提前终止查询。 使用limit的时候。在发现已经满足查询需求的时候，MySQL总是能够立刻终止查询。</li><li>等值传播。如果两列上的值通过等式关联，那么MySQL能够把其中一个列的where条件传递到另一列上。</li><li>列表in()的比较</li></ul></li><li><p>MySQL如何执行关联查询。</p><blockquote><p>MySQL对任何关联都执行<strong>嵌套循环关联</strong>操作，即MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止。然后根据各个表匹配的行，返回查询中需要的各个列。MySQL会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表中无法找到更多的行以后，MySQL返回到上一层次关联表，看是否能够找到更多的匹配记录，以此类推迭代执行。</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select tbl1.col1, tbl2.col2</span><br><span class="line">    -&gt; from tbl1 inner join tbl2 useing(col3)</span><br><span class="line">    -&gt; where tbl1.col1 in (5,6);</span><br></pre></td></tr></table></figure><p>  我们使用伪代码表示MySQL如何执行这个查询。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">outer_iter = iterator over tbl1 where col1 in(5,6)</span><br><span class="line">ourter_row = outer.iter.next</span><br><span class="line">while outer_row</span><br><span class="line">    inner_iter = iterator over tbl2 where col3 = outer_row.col3</span><br><span class="line">    inner_row = inner_iter.next</span><br><span class="line">    while inner_row</span><br><span class="line">        output [ outer_row.col1, inner_row.col2 ]</span><br><span class="line">        inner_row = inner_iter.next</span><br><span class="line">    end</span><br><span class="line">    outer_row = outer_iter.next</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>  <img src="/2018/10/21/mysql查询优化/how_to_join.png" alt="MySQL如何完成关联查询"></p><ul><li>全外连接无法通过嵌套循环和回溯的方式实现，这大概也是MySQL不支持全外连接的原因。我记得我最早期面试的时候曾经被问到过MySQL有全外连接吗？但是回答的是，现在想想太丢人了。其实这个问题完全可以提现出一个人是不是了解过MySQL执行原理。</li></ul></li><li>执行计划<ul><li>如果对某个查询执行 EXPALAN EXTENDED 后，再执行 SHOW WARNINGS, 就可以看到重构出的查询。</li><li>关联查询优化通过评估join不同顺序时的成本来选择一个代价最小的关联顺序。不过有时候，优化器给出的并不是最优的关联顺序。这是可以使用 STRIGHT_JOIN 关键字重写查询。</li><li>当表的关联数量过多时。优化器会选择使用“贪婪”搜索方式查找”最优”的关联顺序。实际上，当需要关联的表超过 optimizer_search_depth的限制的时候，就会选择”贪婪搜索”模式了。（个人不建议过多表关联）</li><li>无论如何排序，都是一个成本很高的操作（个人感触很深，尤其join，limit操作如果排序和不排序，耗时差异很大，之后会有这方面经验讨论），从新能角度考虑，尽可能避免排序。</li></ul></li></ul></li><li>执行查询计划</li><li>返回给客户端</li></ol><h2 id="MySQL-查询优化器的局限性"><a href="#MySQL-查询优化器的局限性" class="headerlink" title="MySQL 查询优化器的局限性"></a>MySQL 查询优化器的局限性</h2><ol><li>关联子查询。（mysql5.6之前的问题。where in （subQuery）会转化成exist操作，感兴趣的同学可以自行搜索，我就不再赘述了。）</li><li><p>在同一个表上查询和更新。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update tbl</span><br><span class="line">    -&gt;      inner join (</span><br><span class="line">    -&gt;          select type, count(*) as cnt</span><br><span class="line">    -&gt;          from tbl</span><br><span class="line">    -&gt;          group by type</span><br><span class="line">    -&gt;      ) as der using(type)</span><br><span class="line">    -&gt; set tbl.cnt = der.cnt</span><br></pre></td></tr></table></figure></li></ol><h2 id="查询优化器的提示（hint）"><a href="#查询优化器的提示（hint）" class="headerlink" title="查询优化器的提示（hint）"></a>查询优化器的提示（hint）</h2><p>&emsp;&emsp;我只计划分析一些可能会用到的，其他的使用可以点击<a href="http://diseng.github.io/2013/09/23/mysql-hints" target="_blank" rel="noopener">这里</a>了解。</p><ul><li>STRIGHT_JOIN 这个提示可以放到select语句之后，也可以放到任何两个关联的表名之间。第一种用法是让查询中所有的表按照在语句中出现的顺序进行关联。第二种用法则是固定其前后两个表的关联顺序。</li><li>use index、ignore index 和 force index。这几个提示会告诉优化器使用或者不使用那些索引查询记录。</li><li>for update 和 lock in share mode select 的锁机制，这个可以引申出另一个概念，乐观锁和悲观锁的概念（我认为这是一个后端程序员必须了解的技能之一）。</li></ul><h2 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h2><ul><li><p>优化limit 分页。</p><ul><li>在偏移量非常大的时候，例如limit 1000,20 这是mysql需要查询1020条，只返回20条数据。这<br>样会有很大的代价。要优化这种查询，一是在页面中限制分页的数量（限制分页数量之后，如果有序的话，可以通过 &gt; 当前页id的方式减少多余行的扫描），二是优化大偏移量的性能。</li><li>优化分页查询的一个最简单的方法就是尽可能的使用<strong>索引覆盖</strong>扫描。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 优化前</span><br><span class="line">mysql &gt; select film_id, description from film order by title limit 50, 5;</span><br><span class="line">// 优化后</span><br><span class="line">mysql &gt; select f.film_id, f.description from film as f</span><br><span class="line">     -&gt; inner join ( select film_id from film order by title limit 50, 5 )</span><br><span class="line">     -&gt; as lim using(film_id)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>MySQL中is not null是不能使用索引的，因此可以通过 &gt; 一个特定最小值的方法改写is not null。MySQL is null 操作会走索引，<a href="https://dev.mysql.com/doc/refman/5.7/en/is-null-optimization.html" target="_blank" rel="noopener">文档</a>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Mysql-查询优化策略&quot;&gt;&lt;a href=&quot;#Mysql-查询优化策略&quot; class=&quot;headerlink&quot; title=&quot;Mysql 查询优化策略&quot;&gt;&lt;/a&gt;Mysql 查询优化策略&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;这篇文章是自己对 &lt;str
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="性能/优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD-%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>hello-hexo</title>
    <link href="http://yoursite.com/2018/10/04/hello-hexo/"/>
    <id>http://yoursite.com/2018/10/04/hello-hexo/</id>
    <published>2018-10-04T03:48:05.000Z</published>
    <updated>2019-06-16T08:10:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-hexo"><a href="#Hello-hexo" class="headerlink" title="Hello hexo"></a>Hello hexo</h1><p>&emsp;&emsp;今年在学习《高性能mysql》这本书的时候，产生的写博客的想法，希望能够记录自己学到的东西，只求打开自己博客的瞬间能够回忆起自己所学。当然，如果我总结的知识能够帮到别人，会更完美。<br><br>&emsp;&emsp;从知乎上了解到hexo这个博客框架，同时因为自已现在主要还是做nodejs开发，hexo用起来一定会相当顺手，就毫不犹豫的选择了。</p><h2 id="Hexo-的搭建过程"><a href="#Hexo-的搭建过程" class="headerlink" title="Hexo 的搭建过程"></a>Hexo 的搭建过程</h2><p>&emsp;&emsp;hexo 的整体配置还是很简单的。</p><ol><li>所有工具最正经的学习路径一定是看 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener"><font color="#3399ea">官方文档</font></a>，hexo提供了中文文档（对于我这个英语半吊子的人来说很舒服）。</li><li>选择一个自己喜欢的主题。当前最火的主题毫无疑问是 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener"><font color="#3399ea">next</font></a>（已经有13k+的star了），这也是我的选择。我最喜欢的scheme 是 pisces。</li><li><a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener"><font color="#3399ea">hexo文档</font></a> 学习，了解更多feature。</li></ol><h2 id="Hexo-使用"><a href="#Hexo-使用" class="headerlink" title="Hexo 使用"></a>Hexo 使用</h2><h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><ul><li>hexo提供了三种默认布局：post、page、draft。</li><li>自定义的布局和post，会存储到 <strong><em>source/_posts</em></strong> 文件夹。</li><li>自定义的layout 都配置在 scaffolds 文件夹中。</li><li>可以编辑 new_post_name 参数来改变默认的文件名称（e.g. :year-:month-:day-:title.md）。</li><li>特殊布局：draft，这种布局会将建立的文章保存到 source/_draft 文件夹，你可以通过 hexo publish [layout] \&lt;title>  将草稿移动到 source/_posts 文件夹。</li><li>草稿默认不会显示在页面中，您可在执行时加上 –draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hello-hexo&quot;&gt;&lt;a href=&quot;#Hello-hexo&quot; class=&quot;headerlink&quot; title=&quot;Hello hexo&quot;&gt;&lt;/a&gt;Hello hexo&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;今年在学习《高性能mysql》这本书的时候，产生的写
      
    
    </summary>
    
    
  </entry>
  
</feed>
